#include <ros/ros.h>
#include <moveit/move_group_interface/move_group_interface.h>
#include <geometry_msgs/Pose.h>
#include <vector>
#include <iostream>
#include <string>
#include <actionlib/client/simple_action_client.h>
#include <moveit_msgs/MoveGroupAction.h>
#include <sensor_msgs/JointState.h>
#include <std_msgs/String.h>
#include <ur_msgs/RobotStateRTMsg.h>
#include <ur_msgs/SetIO.h>

class DrawingRobot {
private:
    ros::NodeHandle nh_;
    moveit::planning_interface::MoveGroupInterface move_group_;
    std::string planning_group_;
    double hover_offset_; // Offset for hovering above the drawing surface
    
    // Add subscribers for monitoring robot state
    ros::Subscriber joint_state_sub_;
    ros::Subscriber robot_state_sub_;
    ros::Subscriber safety_state_sub_;
    
    // Add service clients for robot IO control
    ros::ServiceClient set_io_client_;
    
    // State variables
    sensor_msgs::JointState latest_joint_state_;
    bool joint_state_received_;
    bool robot_ready_;
    bool safety_enabled_;
    
    // Add synchronization timeout parameters
    const double sync_timeout_ = 5.0; // Maximum time to wait for sync in seconds
    const double position_tolerance_ = 0.005; // Tighter tolerance for real robot
    
    // Robot-specific parameters
    const double velocity_scaling_default_ = 0.1;  // Start with 10% of max velocity
    const double acceleration_scaling_default_ = 0.1;  // Start with 10% of max acceleration
    
    // Max velocity and acceleration scaling factors (can be adjusted during operation)
    double velocity_scaling_;
    double acceleration_scaling_;

public:
    // Constructor
    DrawingRobot(const std::string& planning_group = "manipulator") 
        : move_group_(planning_group), 
          planning_group_(planning_group), 
          joint_state_received_(false),
          robot_ready_(false),
          safety_enabled_(true),
          velocity_scaling_(velocity_scaling_default_),
          acceleration_scaling_(acceleration_scaling_default_) {
        
        // Configure move group settings
        configureMovement();
        
        // Set default values for drawing
        hover_offset_ = 0.02; // 2cm above waypoint when hovering
        
        // Setup monitoring subscribers
        joint_state_sub_ = nh_.subscribe("/joint_states", 10, &DrawingRobot::jointStateCallback, this);
        robot_state_sub_ = nh_.subscribe("/ur_hardware_interface/robot_state", 10, &DrawingRobot::robotStateCallback, this);
        safety_state_sub_ = nh_.subscribe("/ur_hardware_interface/safety_status", 10, &DrawingRobot::safetyStateCallback, this);
        
        // Setup IO control service client
        set_io_client_ = nh_.serviceClient<ur_msgs::SetIO>("/ur_hardware_interface/set_io");
        
        // Wait for robot connections to establish
        ROS_INFO("Waiting for robot connections to establish...");
        ros::Time start_time = ros::Time::now();
        while (!joint_state_received_ && (ros::Time::now() - start_time).toSec() < sync_timeout_) {
            ros::Duration(0.1).sleep();
            ros::spinOnce();
        }
        
        if (!joint_state_received_) {
            ROS_WARN("No joint state received within timeout. Check robot connection.");
        } else {
            ROS_INFO("Robot connection established.");
            robot_ready_ = true;
        }
        
        // Wait for the controller to stabilize
        waitForControllerSync(3.0);
    }

    // Joint state callback
    void jointStateCallback(const sensor_msgs::JointState::ConstPtr& msg) {
        latest_joint_state_ = *msg;
        joint_state_received_ = true;
    }
    
    // Robot state callback for monitoring hardware status
    void robotStateCallback(const ur_msgs::RobotStateRTMsg::ConstPtr& msg) {
        // Update robot state information
        // For a real UR3, you might want to check various fields in the message
        // to ensure the robot is in the correct operational mode
    }
    
    // Safety state callback
    void safetyStateCallback(const std_msgs::String::ConstPtr& msg) {
        // For a real UR3, you might need to monitor and respond to safety status
        // This is a simplified example, real implementation depends on how safety data is published
        if (msg->data == "PROTECTIVE_STOP" || msg->data == "EMERGENCY_STOP") {
            safety_enabled_ = false;
            ROS_ERROR("Safety stop detected! Robot requires reset.");
        } else if (msg->data == "NORMAL") {
            safety_enabled_ = true;
        }
    }
    
    // Check if the robot is in an operational state
    bool isRobotOperational() {
        return robot_ready_ && safety_enabled_ && joint_state_received_;
    }
    
    // Control tool IO (e.g., for a pen up/down mechanism)
    bool setToolIO(int pin, bool state) {
        ur_msgs::SetIO srv;
        srv.request.fun = 1;  // Set digital output
        srv.request.pin = pin;  // Pin number
        srv.request.state = state ? 1.0 : 0.0;  // ON/OFF
        
        if (set_io_client_.call(srv)) {
            ROS_INFO("Successfully set tool IO pin %d to %s", pin, state ? "ON" : "OFF");
            return srv.response.success;
        } else {
            ROS_ERROR("Failed to set tool IO");
            return false;
        }
    }

    // Configure movement parameters
    void configureMovement() {
        // Set max velocity and acceleration scaling - lower for real robot
        move_group_.setMaxVelocityScalingFactor(velocity_scaling_);
        move_group_.setMaxAccelerationScalingFactor(acceleration_scaling_);
        
        // Set planning time
        move_group_.setPlanningTime(5.0);  // Give the planner more time (5 seconds)
        
        // Set goal tolerances - tighter for real robot
        move_group_.setGoalJointTolerance(0.01);  // 0.01 radians tolerance for joints
        move_group_.setGoalPositionTolerance(0.001);  // 1mm position tolerance
        move_group_.setGoalOrientationTolerance(0.01);  // 0.01 radians orientation tolerance
        
        // Enable collision checking - more important for real robot
        move_group_.setPlannerId("RRTConnectkConfigDefault");
        
        // Print reference frame and end effector info
        ROS_INFO("Reference frame: %s", move_group_.getPlanningFrame().c_str());
        ROS_INFO("End effector link: %s", move_group_.getEndEffectorLink().c_str());
    }
    
    // Set velocity scaling
    void setVelocityScaling(double scaling) {
        if (scaling > 0.0 && scaling <= 1.0) {
            velocity_scaling_ = scaling;
            move_group_.setMaxVelocityScalingFactor(velocity_scaling_);
            ROS_INFO("Velocity scaling set to %.2f", velocity_scaling_);
        } else {
            ROS_WARN("Invalid velocity scaling value: %.2f. Must be between 0.0 and 1.0", scaling);
        }
    }
    
    // Set acceleration scaling
    void setAccelerationScaling(double scaling) {
        if (scaling > 0.0 && scaling <= 1.0) {
            acceleration_scaling_ = scaling;
            move_group_.setMaxAccelerationScalingFactor(acceleration_scaling_);
            ROS_INFO("Acceleration scaling set to %.2f", acceleration_scaling_);
        } else {
            ROS_WARN("Invalid acceleration scaling value: %.2f. Must be between 0.0 and 1.0", scaling);
        }
    }

    // Improved sync function that waits for controller to stabilize
    bool waitForControllerSync(double timeout = 2.0) {
        ROS_INFO("Waiting for controller to synchronize...");
        
        if (!isRobotOperational()) {
            ROS_ERROR("Robot is not operational. Cannot synchronize.");
            return false;
        }
        
        ros::Time start_time = ros::Time::now();
        std::vector<double> prev_positions;
        bool is_stable = false;
        
        // Get initial state to compare
        std::vector<double> initial_positions = getCurrentJointPositions();
        prev_positions = initial_positions;
        
        while ((ros::Time::now() - start_time).toSec() < timeout) {
            // Sleep a bit before checking again
            ros::Duration(0.1).sleep();
            ros::spinOnce();
            
            // Check if robot is still operational
            if (!isRobotOperational()) {
                ROS_ERROR("Robot became non-operational during sync wait.");
                return false;
            }
            
            // Get current joint positions
            std::vector<double> current_positions = getCurrentJointPositions();
            
            // Check if current positions are close to previous positions (stabilized)
            bool all_stable = true;
            for (size_t i = 0; i < current_positions.size() && i < prev_positions.size(); ++i) {
                if (std::abs(current_positions[i] - prev_positions[i]) > 0.0005) { // Tighter threshold for real robot
                    all_stable = false;
                    break;
                }
            }
            
            if (all_stable) {
                // We've detected stability for one cycle, but let's confirm
                // by waiting a bit more and checking again
                ros::Duration(0.2).sleep();
                ros::spinOnce();
                current_positions = getCurrentJointPositions();
                
                all_stable = true;
                for (size_t i = 0; i < current_positions.size() && i < prev_positions.size(); ++i) {
                    if (std::abs(current_positions[i] - prev_positions[i]) > 0.0005) {
                        all_stable = false;
                        break;
                    }
                }
                
                if (all_stable) {
                    is_stable = true;
                    break;
                }
            }
            
            prev_positions = current_positions;
        }
        
        if (is_stable) {
            ROS_INFO("Controller synchronized successfully.");
            return true;
        } else {
            ROS_WARN("Controller synchronization timed out. Proceeding with caution.");
            return false;
        }
    }

    // Get current joint positions
    std::vector<double> getCurrentJointPositions() {
        return move_group_.getCurrentJointValues();
    }

    // Validate that joint positions are within expected tolerance of target
    bool validateJointPositions(const std::vector<double>& target_joints, double tolerance = 0.02) {
        if (!isRobotOperational()) {
            ROS_ERROR("Robot is not operational. Cannot validate joint positions.");
            return false;
        }
        
        std::vector<double> current_joints = getCurrentJointPositions();
        
        if (current_joints.size() != target_joints.size()) {
            ROS_ERROR("Joint validation failed: different number of joints in target vs current");
            return false;
        }
        
        for (size_t i = 0; i < current_joints.size(); ++i) {
            if (std::abs(current_joints[i] - target_joints[i]) > tolerance) {
                ROS_WARN("Joint %zu position mismatch: target=%f, current=%f", 
                        i, target_joints[i], current_joints[i]);
                return false;
            }
        }
        
        return true;
    }

    // Initialize robot to a specific joint configuration with improved synchronization
    bool initializeToPosition(const std::vector<double>& target_joint_positions) {
        ROS_INFO("Initializing robot to specified joint configuration...");
        
        if (!isRobotOperational()) {
            ROS_ERROR("Robot is not operational. Cannot initialize position.");
            return false;
        }
        
        // Get current joint positions for logging
        std::vector<double> current_joints = getCurrentJointPositions();
        
        std::string current_joints_str = "";
        for (double val : current_joints) {
            current_joints_str += std::to_string(val) + " ";
        }
        ROS_INFO("Current joint positions: [%s]", current_joints_str.c_str());
        
        std::string target_joints_str = "";
        for (double val : target_joint_positions) {
            target_joints_str += std::to_string(val) + " ";
        }
        ROS_INFO("Target joint positions: [%s]", target_joints_str.c_str());
        
        // Check if the target position is reachable and collision-free
        if (!validateTargetFeasibility(target_joint_positions)) {
            ROS_ERROR("Target position validation failed. Not attempting movement.");
            return false;
        }
        
        // IMPORTANT: Explicitly sync the start state with the current robot state
        move_group_.setStartStateToCurrentState();
        
        // Wait for controller to stabilize
        waitForControllerSync();
        
        // Set joint value target
        move_group_.setJointValueTarget(target_joint_positions);
        
        // Plan and execute motion
        moveit::planning_interface::MoveGroupInterface::Plan my_plan;
        bool success = (move_group_.plan(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);
    
        if (success) {
            ROS_INFO("Executing movement to initial configuration...");
            move_group_.execute(my_plan);
            
            // Wait for execution to complete and controller to stabilize
            waitForControllerSync(5.0);  // Longer wait for physical robot
            
            // Validate that we reached the target position
            if (validateJointPositions(target_joint_positions)) {
                ROS_INFO("Successfully moved to specified joint configuration.");
                return true;
            } else {
                ROS_WARN("Robot did not reach target configuration within tolerance.");
                return false;
            }
        } else {
            ROS_ERROR("Failed to plan movement to initial configuration.");
            return false;
        }
    }
    
    // Validate target feasibility
    bool validateTargetFeasibility(const std::vector<double>& target_joints) {
        // Simplified check - you might want more comprehensive validation for a real robot
        
        // Check joint limits
        std::vector<std::string> joint_names = move_group_.getJointNames();
        for (size_t i = 0; i < target_joints.size() && i < joint_names.size(); ++i) {
            // Hard-coded UR3 joint limits (you should get these from the URDF)
            double lower_limit = -M_PI;  // -180 degrees
            double upper_limit = M_PI;   // 180 degrees
            
            // Shoulder lift and elbow joints have different limits
            if (joint_names[i].find("shoulder_lift") != std::string::npos) {
                lower_limit = -M_PI;  // -180 degrees
                upper_limit = 0.0;    // 0 degrees
            } else if (joint_names[i].find("elbow") != std::string::npos) {
                lower_limit = 0.0;    // 0 degrees
                upper_limit = M_PI;   // 180 degrees
            }
            
            if (target_joints[i] < lower_limit || target_joints[i] > upper_limit) {
                ROS_ERROR("Joint %s target value %.4f is outside limits [%.4f, %.4f]", 
                         joint_names[i].c_str(), target_joints[i], lower_limit, upper_limit);
                return false;
            }
        }
        
        return true;
    }

    // Get current pose
    geometry_msgs::Pose getCurrentPose() {
        return move_group_.getCurrentPose().pose;
    }
    
    // Create a hover pose above a drawing pose
    geometry_msgs::Pose getHoverPose(const geometry_msgs::Pose& drawing_pose) {
        geometry_msgs::Pose hover_pose = drawing_pose;
        hover_pose.position.z += hover_offset_;
        return hover_pose;
    }
    
    // Create a pose from x,y,z coordinates
    geometry_msgs::Pose makePose(double x, double y, double z) {
        geometry_msgs::Pose pose;
        pose.position.x = x;
        pose.position.y = y;
        pose.position.z = z;
        
        // Set orientation - pen pointing down (may need adjustment for your specific setup)
        pose.orientation.x = 0.0;
        pose.orientation.y = 1.0;
        pose.orientation.z = 0.0;
        pose.orientation.w = 0.0;
        
        return pose;
    }
    
    // Move to a specific pose with improved synchronization
    bool moveToPose(const geometry_msgs::Pose& target_pose) {
        // Print the target coordinates
        ROS_INFO("Moving to: [%f, %f, %f]", 
                 target_pose.position.x, 
                 target_pose.position.y, 
                 target_pose.position.z);
        
        if (!isRobotOperational()) {
            ROS_ERROR("Robot is not operational. Cannot move to pose.");
            return false;
        }
        
        // Check if the target pose is reachable and collision-free
        if (!validateTargetFeasibility(target_pose)) {
            ROS_ERROR("Target pose validation failed. Not attempting movement.");
            return false;
        }
        
        // IMPORTANT: Explicitly sync the start state with the current robot state
        move_group_.setStartStateToCurrentState();
        
        // Wait for controller to stabilize
        waitForControllerSync();
        
        // Set the target pose
        move_group_.setPoseTarget(target_pose);
        
        // Plan and execute
        moveit::planning_interface::MoveGroupInterface::Plan plan;
        bool success = (move_group_.plan(plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);
        
        if (success) {
            // Record start time to measure execution duration
            ros::Time start_time = ros::Time::now();
            
            // Execute the motion
            move_group_.execute(plan);
            
            // Wait for execution to complete and controller to stabilize
            waitForControllerSync(3.0);
            
            ros::Time end_time = ros::Time::now();
            double duration = (end_time - start_time).toSec();
            
            ROS_INFO("Reached target pose (execution time: %.2f seconds)", duration);
            return true;
        } else {
            ROS_ERROR("Planning failed");
            return false;
        }
    }
    
    // Validate pose feasibility
    bool validateTargetFeasibility(const geometry_msgs::Pose& target_pose) {
        // For a physical UR3, we need to check if the target pose is within the workspace
        
        // Get the robot's base frame (usually "base_link")
        std::string base_frame = move_group_.getPlanningFrame();
        
        // Define workspace limits - adjust these to your specific setup
        double x_min = -0.6, x_max = 0.6;
        double y_min = -0.6, y_max = 0.6;
        double z_min = 0.0, z_max = 0.8;
        
        // Check if target is within workspace
        if (target_pose.position.x < x_min || target_pose.position.x > x_max ||
            target_pose.position.y < y_min || target_pose.position.y > y_max ||
            target_pose.position.z < z_min || target_pose.position.z > z_max) {
            
            ROS_ERROR("Target pose [%.3f, %.3f, %.3f] is outside workspace limits", 
                     target_pose.position.x, target_pose.position.y, target_pose.position.z);
            return false;
        }
        
        return true;
    }
    
    // Execute Cartesian path through waypoints with improved synchronization for real robot
    bool executeCartesianPath(const std::vector<std::vector<double>>& waypoints) {
        if (waypoints.empty()) {
            ROS_ERROR("No waypoints provided for path");
            return false;
        }
        
        if (!isRobotOperational()) {
            ROS_ERROR("Robot is not operational. Cannot execute Cartesian path.");
            return false;
        }
        
        ROS_INFO("Starting Cartesian path execution with %lu waypoints", waypoints.size());
        
        // Convert first waypoint to geometry_msgs::Pose
        geometry_msgs::Pose first_pose = makePose(waypoints[0][0], waypoints[0][1], waypoints[0][2]);
        
        // Start by moving to hover position above first waypoint
        geometry_msgs::Pose hover_pose = getHoverPose(first_pose);
        
        if (!moveToPose(hover_pose)) {
            ROS_ERROR("Failed to move to hover position above starting point");
            return false;
        }
        
        // Wait for controller to stabilize
        waitForControllerSync();
        
        // Activate tool (e.g., lower pen) - adjust pin number as needed
        setToolIO(0, true); // Turn on digital output 0
        
        // Lower to starting point
        if (!moveToPose(first_pose)) {
            ROS_ERROR("Failed to lower to starting point");
            setToolIO(0, false); // Turn off tool
            return false;
        }
        
        // Wait for controller to stabilize
        waitForControllerSync();
        
        // Prepare waypoint poses for Cartesian path
        std::vector<geometry_msgs::Pose> waypoint_poses;
        
        // Start from the second waypoint (index 1) since we're already at the first
        for (size_t i = 1; i < waypoints.size(); i++) {
            // Make sure each waypoint has at least x, y, z coordinates
            if (waypoints[i].size() >= 3) {
                geometry_msgs::Pose pose = makePose(waypoints[i][0], waypoints[i][1], waypoints[i][2]);
                
                // Validate waypoint feasibility
                if (!validateTargetFeasibility(pose)) {
                    ROS_WARN("Waypoint %lu is not feasible. Skipping.", i);
                    continue;
                }
                
                waypoint_poses.push_back(pose);
                ROS_INFO("Added waypoint %lu: [%f, %f, %f]", 
                         i, waypoints[i][0], waypoints[i][1], waypoints[i][2]);
            } else {
                ROS_WARN("Skipping waypoint %lu - insufficient coordinates", i);
            }
        }
        
        if (waypoint_poses.empty()) {
            ROS_ERROR("No valid waypoints to follow after the first one");
            setToolIO(0, false); // Turn off tool
            return false;
        }
        
        // IMPORTANT: Explicitly sync the start state with the current robot state
        move_group_.setStartStateToCurrentState();
        
        // Wait for controller to stabilize
        waitForControllerSync();
        
        // For real robot, use smaller step size for more accurate path following
        double step_size = 0.005; // 5mm steps
        
        // Execute the Cartesian path
        moveit_msgs::RobotTrajectory trajectory;
        double fraction = move_group_.computeCartesianPath(
            waypoint_poses, step_size, 0.0, trajectory);
        
        ROS_INFO("Computed Cartesian path (%.2f%% achieved)", fraction * 100.0);
        
        // Special handling for real robot - slow down Cartesian paths for better accuracy
        if (trajectory.joint_trajectory.points.size() > 0) {
            double time_scale_factor = 1.5;  // Stretch time by 1.5x for smoother execution
            for (size_t i = 0; i < trajectory.joint_trajectory.points.size(); ++i) {
                trajectory.joint_trajectory.points[i].time_from_start *= time_scale_factor;
            }
        }
        
        if (fraction >= 0.95) {
            // Record start time to measure execution duration
            ros::Time start_time = ros::Time::now();
            
            // Execute the motion
            move_group_.execute(trajectory);
            
            // Wait for execution to complete and controller to stabilize
            waitForControllerSync(3.0);
            
            ros::Time end_time = ros::Time::now();
            double duration = (end_time - start_time).toSec();

            ROS_INFO("Executed Cartesian path successfully (execution time: %.2f seconds)", duration);
            
            // Lift the pen after completion
            hover_pose = getHoverPose(move_group_.getCurrentPose().pose);
            moveToPose(hover_pose);
            
            // Deactivate tool (e.g., lift pen)
            setToolIO(0, false); // Turn off digital output 0
            
            return true;
        } else {
            ROS_WARN("Could only compute %.2f%% of the Cartesian path", fraction * 100.0);
            
            // For real robot, we want to be more cautious about partial path execution
            if (fraction > 0.8) {  // Higher threshold for physical robot
                ROS_INFO("Executing partial Cartesian path...");
                
                // Record start time to measure execution duration
                ros::Time start_time = ros::Time::now();
                
                // Execute the motion
                move_group_.execute(trajectory);
                
                // Wait for execution to complete and controller to stabilize
                waitForControllerSync(3.0);
                
                ros::Time end_time = ros::Time::now();
                double duration = (end_time - start_time).toSec();
                
                ROS_INFO("Executed partial Cartesian path (execution time: %.2f seconds)", duration);
                
                // Lift the pen after completion
                hover_pose = getHoverPose(move_group_.getCurrentPose().pose);
                moveToPose(hover_pose);
                
                // Deactivate tool (e.g., lift pen)
                setToolIO(0, false); // Turn off digital output 0
                
                return true;
            } else {
                ROS_ERROR("Path completion percentage too low for physical robot. Aborting.");
                
                // Deactivate tool (e.g., lift pen)
                setToolIO(0, false); // Turn off digital output 0
                
                return false;
            }
        }
    }
    
    // Add a robust recovery method to handle joint state errors
    bool recoverFromJointStateError(int retry_count = 3) {
        ROS_INFO("Attempting to recover from joint state error...");
        
        if (!isRobotOperational()) {
            ROS_ERROR("Robot is not operational. Cannot recover from error.");
            return false;
        }
        
        for (int i = 0; i < retry_count; i++) {
            ROS_INFO("Recovery attempt %d of %d", i+1, retry_count);
            
            // Get current joint positions
            std::vector<double> current_joints = getCurrentJointPositions();
            
            // IMPORTANT: Explicitly sync the start state with the current robot state
            move_group_.setStartStateToCurrentState();
            
            // Wait longer to ensure state sync
            waitForControllerSync(1.0);
            
            // For real robot, use very small movements to reset
            std::vector<double> slightly_modified_joints = current_joints;
            for (size_t j = 0; j < slightly_modified_joints.size(); j++) {
                slightly_modified_joints[j] += 0.005; // Half degree offset to minimize movement
            }
            
            // Use very slow movement for recovery
            double saved_velocity = velocity_scaling_;
            double saved_acceleration = acceleration_scaling_;
            
            setVelocityScaling(0.05); // 5% speed for recovery
            setAccelerationScaling(0.05); // 5% acceleration for recovery
            
            move_group_.setJointValueTarget(slightly_modified_joints);
            
            moveit::planning_interface::MoveGroupInterface::Plan recovery_plan;
            bool success = (move_group_.plan(recovery_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);
            
            if (success) {
                move_group_.execute(recovery_plan);
                
                // Wait for execution to complete and controller to stabilize
                bool sync_success = waitForControllerSync(3.0);
                
                // Restore original speed settings
                setVelocityScaling(saved_velocity);
                setAccelerationScaling(saved_acceleration);
                
                if (sync_success) {
                    ROS_INFO("Recovery move succeeded");
                    return true;
                } else {
                    ROS_WARN("Recovery move executed but controller sync failed");
                }
            } else {
                ROS_ERROR("Recovery move planning failed");
                
                // Restore original speed settings
                setVelocityScaling(saved_velocity);
                setAccelerationScaling(saved_acceleration);
            }
            
            // If we're here, the attempt failed - wait before next try
            ros::Duration(1.0).sleep();
        }
        
        ROS_ERROR("All recovery attempts failed");
        return false;
    }
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, "ur3_cartesian_waypoints");
    ros::AsyncSpinner spinner(2); // Use 2 threads for better responsiveness
    spinner.start();
    
    ROS_INFO("Starting UR3 Cartesian waypoint following program for real robot");
    
    // Initialize the robot interface
    DrawingRobot robot;
    
    // Allow more time for ROS to fully initialize and connect to the robot
    ros::Duration(3.0).sleep();
    
    // Print current joint positions
    std::vector<double> current_joints = robot.getCurrentJointPositions();
    std::string joints_str = "";
    for (double val : current_joints) {
        joints_str += std::to_string(val) + " ";
    }
    ROS_INFO("Robot starting joint positions: [%s]", joints_str.c_str());

    // Define the desired initial joint configuration
    std::vector<double> initial_joint_positions = {0.0, -0.894, 2.392, -3.077, -1.576, 0.0};
    
    // Initialize robot with the specified joint configuration
    bool init_success = robot.initializeToPosition(initial_joint_positions);
    
    // If initialization fails, try recovery and retry
    if (!init_success) {
        ROS_WARN("Initial movement failed. Attempting recovery...");
        robot.recoverFromJointStateError();
        
        // Try again after recovery
        init_success = robot.initializeToPosition(initial_joint_positions);
        if (!init_success) {
            ROS_ERROR("Failed to initialize robot even after recovery attempt");
            return 1;
        }
    }
    
    ROS_INFO("Robot successfully initialized to specified joint configuration");
    
    // Define Cartesian waypoints as a variable
    // Each sub-vector contains {x, y, z} coordinates
    std::vector<std::vector<double>> cartesian_waypoints = {
        {0.3, 0.2, 0.1},    // Starting point
        {0.3, 0.3, 0.1},    // Next point
        {0.4, 0.3, 0.1},    // Next point
        {0.4, 0.2, 0.1},    // Next point
        {0.3, 0.2, 0.1}     // Back to starting point (closed path)
    };
    
    ROS_INFO("Executing Cartesian path through defined waypoints");
    
    // Execute the Cartesian path
    bool path_success = robot.executeCartesianPath(cartesian_waypoints);
    
    // If path execution fails, try recovery and retry with more robust error handling
    if (!path_success) {
        ROS_WARN("Cartesian path execution failed. Attempting recovery...");
        
        if (robot.recoverFromJointStateError(3)) {
            // Try again after recovery, but with a smaller subset of waypoints
            // to increase chances of success
            ROS_INFO("Retrying with simplified path");
            std::vector<std::vector<double>> simplified_waypoints;
            
            // Only keep every other waypoint to simplify the path
            for (size_t i = 0; i < cartesian_waypoints.size(); i += 2) {
                simplified_waypoints.push_back(cartesian_waypoints[i]);
            }
            
            // Make sure we still have the last point to close the path
            if (simplified_waypoints.back() != cartesian_waypoints.back()) {
                simplified_waypoints.push_back(cartesian_waypoints.back());
            }
            
            path_success = robot.executeCartesianPath(simplified_waypoints);
            
            if (!path_success) {
                ROS_ERROR("Failed to execute even simplified Cartesian path");
            }
        }
    }
    
    // Return to the initial joint configuration with improved error handling
    ROS_INFO("Returning to initial configuration");
    bool return_success = robot.initializeToPosition(initial_joint_positions);
    
    if (!return_success) {
        ROS_WARN("Failed to return to initial configuration. Attempting recovery...");
        robot.recoverFromJointStateError();
        robot.initializeToPosition(initial_joint_positions);
    }
    
    ROS_INFO("Program completed");
    ros::shutdown();
    return 0;
}